import 'package:flutter_bloc/flutter_bloc.dart';
import '../data/order_data_source.dart';
import '../domain/order.dart';
import '../../../core/error/failures.dart';
import '../../../core/error/exceptions.dart';
import '../../../core/constants/app_constants.dart';
import 'order_event.dart';
import 'order_state.dart';

class OrderBloc extends Bloc<OrderEvent, OrderState> {
  final OrderDataSource dataSource;

  OrderBloc({required this.dataSource}) : super(const OrderInitial()) {
    on<PlaceOrder>(_onPlaceOrder);
    on<LoadOrders>(_onLoadOrders);
    on<LoadOrderById>(_onLoadOrderById);
    on<RefreshOrderStatus>(_onRefreshOrderStatus);
  }

  Future<void> _onPlaceOrder(PlaceOrder event, Emitter<OrderState> emit) async {
    emit(const OrderPlacing());

    try {
      final order = Order(
        id: '', // Will be generated by data source
        restaurantId: event.restaurantId,
        restaurantName: event.restaurantName,
        items: event.items,
        subtotal: event.subtotal,
        deliveryFee: event.deliveryFee,
        serviceFee: event.serviceFee,
        total: event.total,
        status: OrderStatus.placed,
        createdAt: DateTime.now(),
        deliveryAddress: event.deliveryAddress,
        specialInstructions: event.specialInstructions,
        estimatedDeliveryTime: AppConstants.estimatedDeliveryTime,
      );

      final placedOrder = await dataSource.placeOrder(order);
      emit(OrderPlaced(placedOrder));
    } on NetworkException catch (e) {
      emit(OrderError(NetworkFailure(e.message)));
    } on ServerException catch (e) {
      emit(OrderError(ServerFailure(e.message)));
    } catch (e) {
      emit(
        OrderError(UnknownFailure('Failed to place order: ${e.toString()}')),
      );
    }
  }

  Future<void> _onLoadOrders(LoadOrders event, Emitter<OrderState> emit) async {
    emit(const OrdersLoading());

    try {
      final orders = await dataSource.getOrders();
      emit(OrdersLoaded(orders));
    } on NetworkException catch (e) {
      emit(OrderError(NetworkFailure(e.message)));
    } on ServerException catch (e) {
      emit(OrderError(ServerFailure(e.message)));
    } catch (e) {
      emit(
        OrderError(UnknownFailure('Failed to load orders: ${e.toString()}')),
      );
    }
  }

  Future<void> _onLoadOrderById(
    LoadOrderById event,
    Emitter<OrderState> emit,
  ) async {
    emit(const OrderLoading());

    try {
      final order = await dataSource.getOrderById(event.orderId);
      emit(OrderLoaded(order));
    } on NetworkException catch (e) {
      emit(OrderError(NetworkFailure(e.message)));
    } on ServerException catch (e) {
      emit(OrderError(ServerFailure(e.message)));
    } catch (e) {
      emit(OrderError(UnknownFailure('Failed to load order: ${e.toString()}')));
    }
  }

  Future<void> _onRefreshOrderStatus(
    RefreshOrderStatus event,
    Emitter<OrderState> emit,
  ) async {
    try {
      final order = await dataSource.getOrderById(event.orderId);
      emit(OrderLoaded(order));
    } on NetworkException catch (e) {
      emit(OrderError(NetworkFailure(e.message)));
    } on ServerException catch (e) {
      emit(OrderError(ServerFailure(e.message)));
    } catch (e) {
      emit(
        OrderError(UnknownFailure('Failed to refresh order: ${e.toString()}')),
      );
    }
  }
}
